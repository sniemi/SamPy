'''
A class to plot COS instrument handbook plots. Each figure 
is generated by it's own function.

Note that the same function can be used to generate multiple
figures of similar type. 

@author: Sami-Matias Niemi (niemi@stsci.edu) for STScI
'''

import matplotlib
matplotlib.rc('text', usetex = True)
matplotlib.rc('xtick', labelsize=12) 
matplotlib.rc('axes', linewidth=1.2)
matplotlib.rc('lines', markeredgewidth=2.0)
matplotlib.rcParams['lines.linewidth'] = 2.5
matplotlib.rcParams['legend.fontsize'] = 11
matplotlib.rcParams['legend.handlelength'] = 5
matplotlib.rcParams['font.size'] = 13
matplotlib.rcParams['xtick.major.size'] = 5
#matplotlib.rcParams['xtick.labelsize'] = 'large'
matplotlib.rcParams['ytick.major.size'] = 5
#matplotlib.rcParams['ytick.labelsize'] = 'large'
matplotlib.rcParams['legend.fancybox'] = True
#matplotlib.rcParams['figure.figsize'] = [12,8]
#matplotlib.rcParams['figure.dpi'] = 100
#matplotlib.rcParams['savefig.dpi'] = 300
matplotlib.use('PDF')

from matplotlib.ticker import MultipleLocator, FormatStrFormatter, NullFormatter, LogLocator
try:
    from mpl_toolkits.mplot3d import Axes3D
except:
    pass
from matplotlib import cm
import matplotlib.mlab as mlab
import matplotlib.pyplot as plt
import matplotlib.collections as collections
import pylab as P
import numpy as N
import matplotlib.cm as cm
import math

__author__ = 'Sami-Matias Niemi'
__version__ = '1.4'

def Sensitivity2EffectiveArea(sensitivity, wavelength, dispersion):
    '''
    '''
    #effective area
    #area = const*sensitivity/(wave*dlam_dx)
    const = 2.998e10 * 6.626e-27 / 1.0e-8 #h*c*1.e-8 (to convert Ang to cm)
    effA = const * sensitivity / (wavelength * dispersion)
    return effA

def Sensitivity2EffectiveAreaForArrays(wave, sens, disp):
    waveA = []
    effA = []
    for w, s in zip(wave, sens):
        waveA.append(w)
        effA.append(Sensitivity2EffectiveArea(s, w, disp))
    return waveA, effA

def Smooth(wave, eff):
    step = 10.
    zero = wave[0]
    w = []
    e = []
    wa = []
    ef = []
    for a, b in zip(wave, eff):
        if a > 1600 and a < 3000:
            if a <= zero + step:
                w.append(a)
                e.append(b)
            else:
                try:
                    max = N.max(N.array(e))
                except:
                    max = b
                wa.append(N.mean(N.array(w)))
                ef.append(max)
                w = []
                e = []  
                zero = a
        else:
            wa.append(a)
            ef.append(b)

    return N.array(wa), N.array(ef)

def Fix(data, smooth = True):
    '''
    Simple function to separate 1st and 2nd-order light from 230L.
    '''
    wave = N.array([w for w, e in data])
    eff = N.array([e for w, e in data])
    #wavelengths that bracket 2nd-order
    maxEW = wave[N.where(eff == max(eff))][0]
    maxEW1 =  wave[N.where(eff == N.max(eff[wave < maxEW]))][0]
    #steps for interpolation
    step = N.array(range(len(wave)))/(len(wave)-1.)*(N.max(wave) - N.min(wave)) + N.min(wave)
    #interpolation between value
    intE = N.interp(step, wave, eff)
    #choose maximum from interpolation
    tmp = N.where(intE > eff)
    eff[tmp] = intE[tmp]
    
    if smooth:
        wa, eb = Smooth(step, eff)
        criterium = (wa <= maxEW1) | (wa >= maxEW)  
        return wa[criterium], eb[criterium]
    else:
        return wave, eff

class Plotting():
    '''
    A class to plot COS instrument handbook plots.
    Each figure is generated by a function.
    '''

    def __init__(self, filetype='.pdf'):
        '''
        Initialization: sets the used file type e.g. eps for the output.
        '''
        self.type = filetype
    
    def FUVsensitivity(self, G130, G160, G140, output):
        '''
        Plots FUV point-source sensitivities in units of effective area
        and throughput.
        '''
        ar = 45238.93416 #HST primary area in cm**2
        
        #fixer
        fixer = 1122.
        
        #Extension for 140L (McCandliss paper data)
        data = N.loadtxt('./data/G140Leff.dat', comments='#', usecols = (0,1))
        
        ax = P.subplot(111)
        #P.title('FUV point-source sensitivities')

        ax2 = ax.twinx()
        
        ax2.plot([line[0] for line in G130],
                 N.array([line[1] for line in G130])/ar, 'b-', label='G130M', zorder = 2)
#        ax2.plot([line[0] for line in G140 if line[0] > fixer],
#                 N.array([line[1] for line in G140 if line[0] > fixer])/ar, 'r-', label='G140L')
        ax2.plot([line[0] for line in data] + [line[0] for line in G140 if line[0] > fixer],
                 N.array([line[1] for line in data] + [line[1] for line in G140 if line[0] > fixer])/ar,
                 'r-', label='G140L', zorder = 2)        
        ax2.plot([line[0] for line in G160],
                 N.array([line[1] for line in G160])/ar, 'g-', label='G160M', zorder = 2)

        ax.plot([line[0] for line in G130],
                [line[1] for line in G130], 'b-', label='G130M', lw = 3, zorder = 2)
#        ax.plot([line[0] for line in G140 if line[0] > fixer],
#                [line[1] for line in G140 if line[0] > fixer], 'r-', label='G140L', lw = 3)
        ax.plot([line[0] for line in data] + [line[0] for line in G140 if line[0] > fixer],
                [line[1] for line in data] + [line[1] for line in G140 if line[0] > fixer],
                'r-', label='G140L', lw = 3, zorder = 2)        
        ax.plot([line[0] for line in G160],
                [line[1] for line in G160], 'g-', label='G160M', lw = 3, zorder = 2)
     

        s = [y for x, y in G130 if x > 1100. and x < 2000.]
        ax.set_ylim(-0.0001, max(s)*1.05)
        ax2.set_ylim(-0.0001, max(s)*1.05/ar)

        ax.set_xlim(920., 2140.)
        ax2.set_xlim(920., 2140.)

        ax.set_xlabel('Wavelength (\AA)')
        ax.set_ylabel('Effective Area (cm$^{2}$)') 
        ax2.set_ylabel('Fractional Throughput') 
        
        xminorLocator = MultipleLocator(50)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)

        ax.yaxis.set_minor_locator(MultipleLocator(500/5))
        ax2.yaxis.set_minor_locator(MultipleLocator(0.01/5))

        ax.set_zorder(20)
        ax2.set_zorder(20)

        P.legend(shadow = True)
        P.savefig(output+self.type)
        P.close()
    
    def FUVsensitivityOLD(self, datax1, datay1, datax2, datay2, datax3, datay3, output):
        '''
        Plots the FUV point-source sensitivities for three grating.
        Corresponds to Figure 5.2 on page 40 at the first COS instrument handbook.
        '''    
        ax = P.subplot(111)
        P.title('FUV point-source sensitivities')
        P.xlabel('Wavelength (\AA)')
        P.ylabel('counts resel$^{-1}$ sec$^{-1}$ per FEFU')      
        P.plot(datax1, datay1, 'b-', label='G130M', lw = 3)
        P.plot(datax2, datay2, 'r-', label='G140L', lw = 3)
        P.plot(datax3, datay3, 'g-', label='G160M', lw = 3)
        P.legend(shadow = True)
        P.xlim(1077., 2140.)
        
        #limits the y axis between realistic values
        s = [y for x, y in zip(datax2, datay2) if x > 1100. and x < 2000.]
        P.ylim(-0.0001, max(s)*1.05)

        xminorLocator = MultipleLocator(50)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)
        P.ylim()
        P.savefig(output+self.type)
        P.close()

    def Chapter13SNPlot(self, data, stlim, grating, wavelength, output, FUV = True):
        '''
        Creates signal-to-noise plots for COS instrument HB Chapter 15.
        Bright limit has been set for point source, should be changed if
        adapted for diffuse source.
        '''
        def convert(x):
            return 10.**(x / -2.5)*3.63e-9
        
        #limiting area factor
        factor = 0.5
        
        second = True
   
        if FUV:
            minmag = 5
            maxmag = 25
            #newer version automatically calculagtes these, thus, no need
            #values taken from Table 11.2 of COS instrument HB, version 1.
            #might require updating!
            #if grating.find('G130M') > -1: stlim = 9.8
            #if grating.find('G160M') > -1: stlim = 7.9
            #if grating.find('G140L') > -1: stlim = 12.3
            if output.find('G130MSSNR') > -1:
                minmag = 3
                maxmag = 16
        else:
            minmag = 0
            maxmag = 25
            #if grating.find('G185M') > -1: stlim = 8.1
            #if grating.find('G225M') > -1: stlim = 7.4
            #if grating.find('G285M') > -1: stlim = 6.6
            #if grating.find('G230L') > -1: stlim = 9.1

        yMajorFormattor = FormatStrFormatter('%i')
        
        ax1 = P.subplot(111)
        
        #ax1.set_xlabel('V + STMAG$_{\lambda}$ (magnitudes)')
        ax1.set_xlabel('STMAG (magnitudes)')
        ax1.set_ylabel('SNR for %s at %s \AA' % (grating, wavelength))

        #x 2 axis
        if second:
            ax2 = ax1.twiny()
            ax2.set_xlabel('Constant $F_{\lambda}$ (erg cm$^{-2}$ s$^{-1}$ \AA$^{-1}$)')

        dark = []
        sky = []
        darkDom = False
        skyDom = False
        for x in data:
            time =  x[0]
            tmp = []
            for y in x[1]:
                #Signal-to-noise ratio, source counts, source noise, dark current counts, sky, background, total noise
                snr = y[1][0]
                sourceCounts = y[1][1]
                sourceNoise = y[1][2]
                darkCounts =  y[1][3]
                skyCounts =  y[1][4]
                background =  y[1][5]
                totalNoise = y[1][6] 
                
                #tests if limitations
                if darkCounts > factor * sourceCounts and snr > 1.0:
                #if darkCounts > factor * totalNoise and snr > 1.0:
                    dark.append([y[0], snr])
                    darkDom = True
                    #print 'Dark limited area found...', y[0], snr
                    
                if skyCounts > factor * sourceCounts and snr > 1.0:
                #if skyCounts > factor * totalNoise and snr > 1.0:
                    sky.append([y[0], snr])
                    skyDom = True
                    #print 'Sky limited area found...', y[0], snr
                    
                tmp.append([y[0], snr]) #(flux, SN)
              
            st = sorted(tmp, key=lambda x:(x[0], x[1]))
            
            #line plots
            if second: ax2.plot([x for x, y in st], [y for x, y in st], visible = False, zorder = 1) 
            ax1.plot([-2.5*math.log10(x/3.63e-9) for x, y in st], [y for x, y in st], label=str(int(time)) + ' s', lw=2., zorder = 1)
        

        #bright limit area
        #stlim = -2.5*math.log10(brightlim/3.63e-9)
        ax1.axvspan(0, stlim, facecolor='r', alpha=0.5, label='Bright Limit', zorder = 2)
        
        dk = sorted(dark, key=lambda x:(x[0], x[1]))
        sk = sorted(sky, key=lambda x:(x[0], x[1]))
        
        #dark
        if darkDom:
            if second: ax2.scatter([x for x, y in dk], [y for x, y in dk], visible = False, zorder = 10)
            ax1.scatter([-2.5*math.log10(x/3.63e-9) for x, y in dk], [y for x, y in dk],
                        s=20, c='b', marker='o', label = 'Dark Dominates', zorder = 10)
        
        #sky
        if skyDom:
            if second: ax2.scatter([x for x, y in sk], [y for x, y in sk], visible = False, zorder = 10)
            ax1.scatter([-2.5*math.log10(x/3.63e-9) for x, y in sk], [y for x, y in sk],
                        s=20, c='r', marker='d', label = 'Sky Dominates', zorder = 10)

        l = ax1.legend(shadow = True, scatterpoints=1)
        l.set_zorder(20)

        #x1 and x2 axis
        if second:
            ax2.set_xscale('log')
            ax2.set_xlim(convert(maxmag), convert(minmag))
            #ax2.xaxis.tick_top()
            xminor = LogLocator(base=10.0, subs=N.arange(0.0, 1.0, 0.2))
            ax2.xaxis.set_minor_locator(xminor)
            ax2.invert_xaxis()
        xminorLocator = MultipleLocator(1)
        ax1.xaxis.set_minor_formatter(NullFormatter())
        ax1.xaxis.set_minor_locator(xminorLocator)
        ax1.xaxis.tick_bottom()

        #y axis
        ax1.set_yscale('log')
        ax1.set_yticks([1,5,10,30,100])    
        ax1.set_xlim(minmag, maxmag)
        ax1.set_ylim(1., 120.)
        if second:
            ax2.set_yscale('log')
            ax2.set_yticks([1,5,10,30,100])
            ax2.set_ylim(1., 120.)
            
        ax1.yaxis.set_major_formatter(yMajorFormattor)
        ax2.yaxis.set_major_formatter(yMajorFormattor)
        ax1.set_zorder(200)
        ax2.set_zorder(200)
        
        P.savefig(output+self.type)
        P.close()

    def Chapeter13SensitivityNew(self, psa, boa, disp, title, output, G140L = False, logy = False):
        '''
        Plots the FUV point-source sensitivities for Chapter 13.
        '''
        boaFactor = 100.
        
        #manipulate data
        PSASegA = [[line[4], line[5]] for line in psa if line[0] == 'FUVA']
        PSASegB = [[line[4], line[5]] for line in psa if line[0] == 'FUVB']        
        BOASegA = [[line[4], line[5]] for line in boa if line[0] == 'FUVA']
        BOASegB = [[line[4], line[5]] for line in boa if line[0] == 'FUVB']
        
        #effective area
        PSASegAw, PSASegAe = Sensitivity2EffectiveAreaForArrays(PSASegA[0][0], PSASegA[0][1], disp)
        PSASegBw, PSASegBe = Sensitivity2EffectiveAreaForArrays(PSASegB[0][0], PSASegB[0][1], disp)
        BOASegAw, BOASegAe = Sensitivity2EffectiveAreaForArrays(BOASegA[0][0], boaFactor*BOASegA[0][1], disp)
        BOASegBw, BOASegBe = Sensitivity2EffectiveAreaForArrays(BOASegB[0][0], boaFactor*BOASegB[0][1], disp)
       
        #plot
        ax1 = P.subplot(111)
        P.title(title)

        #two axis
        ax2 = ax1.twinx()
        
        #plot, axis 1
        ax1.set_xlabel('Wavelength (\AA)')
        ax1.set_ylabel('counts pixel$^{-1}$ s$^{-1}$ / (erg s$^{-1}$ cm$^{-2}$ \AA$^{-1}$)')      
        ax1.plot(PSASegA[0][0], PSASegA[0][1], 'r-', label='PSA Segment A', lw = 3)
        ax1.plot(PSASegB[0][0], PSASegB[0][1], 'r:', label='PSA Segment B', lw = 3)
        ax1.plot(BOASegA[0][0], boaFactor*BOASegA[0][1], 'g--', label='BOA x %i Segment A' % int(boaFactor), lw = 3)
        ax1.plot(BOASegB[0][0], boaFactor*BOASegB[0][1], 'g-.', label='BOA x %i Segment B' % int(boaFactor), lw = 3)
       #plot, axis2
        ax2.set_ylabel('Effective Area (cm$^{2}$)')
        ax2.yaxis.tick_right()
        ax2.plot(PSASegAw, PSASegAe, 'r-', lw = 3)#, visible = False)
        ax2.plot(PSASegBw, PSASegBe, 'r:', lw = 3)#, visible = False)
        ax2.plot(BOASegAw, BOASegAe, 'g--', lw = 3)#, visible = False)
        ax2.plot(BOASegBw, BOASegBe, 'g-.', lw = 3)#, visible = False)
        
        if G140L:
            s = [y for x, y in zip(PSASegA[0][0], PSASegA[0][1]) if x > 1100. and x < 2000.]
            P.ylim(min(BOASegA[0][1]), max(s)*1.02)

        m = ax1.get_yticks()[1] - ax1.get_yticks()[0]
        yminorLocator = MultipleLocator(m/5)
        yminorFormattor = NullFormatter()
        ax1.yaxis.set_minor_locator(yminorLocator)
        ax1.yaxis.set_minor_formatter(yminorFormattor)      
        
        if G140L:
            P.xlim(940, 2140)
            xminorLocator = MultipleLocator(50)
            xminorFormattor = NullFormatter()
            ax1.xaxis.set_minor_locator(xminorLocator)
            ax1.xaxis.set_minor_formatter(xminorFormattor) 
        elif title == 'G230L':
            P.xlim(1000, 3250)
            xminorLocator = MultipleLocator(100)
            xminorFormattor = NullFormatter()
            ax1.xaxis.set_minor_locator(xminorLocator)
            ax1.xaxis.set_minor_formatter(xminorFormattor)
        else:
            xminorLocator = MultipleLocator(25)
            xminorFormattor = NullFormatter()
            ax1.xaxis.set_minor_locator(xminorLocator)
            ax1.xaxis.set_minor_formatter(xminorFormattor)
        if logy: ax1.set_yscale('log')

        #delete the lowest tick
        ax2.set_yticks(ax2.get_yticks()[1:])
        ax1.set_yticks(ax1.get_yticks()[1:])

        ax1.legend(shadow = True)

        P.savefig(output+self.type)
        P.close()
    
    def Chapeter13Sensitivity(self, psa, boa, title, output, G140L = False, logy = False):
        '''
        Plots the FUV point-source sensitivities for Chapter 13.
        '''
        boaFactor = 100.
        
        #manipulate data
        PSASegA = [[line[4], line[5]] for line in psa if line[0] == 'FUVA']
        PSASegB = [[line[4], line[5]] for line in psa if line[0] == 'FUVB']        
        BOASegA = [[line[4], line[5]] for line in boa if line[0] == 'FUVA']
        BOASegB = [[line[4], line[5]] for line in boa if line[0] == 'FUVB']
       
        #plot
        ax1 = P.subplot(111)
        P.title(title)
        ax1.set_xlabel('Wavelength (\AA)')
        ax1.set_ylabel('counts pixel$^{-1}$ s$^{-1}$ / (erg s$^{-1}$ cm$^{-2}$ \AA$^{-1}$)')      
        ax1.plot(PSASegA[0][0], PSASegA[0][1], 'r-', label='PSA Segment A', lw = 3)
        ax1.plot(PSASegB[0][0], PSASegB[0][1], 'r:', label='PSA Segment B', lw = 3)
        ax1.plot(BOASegA[0][0], boaFactor*BOASegA[0][1], 'g--', label='BOA x %i Segment A' % int(boaFactor), lw = 3)
        ax1.plot(BOASegB[0][0], boaFactor*BOASegB[0][1], 'g-.', label='BOA x %i Segment B' % int(boaFactor), lw = 3)
       
        ax1.legend(shadow = True)
        #ax2 = ax1.twinx()
        #ax2.set_ylabel('another axis (to be decided)')
        #ax2.yaxis.tick_right()
        #ax2.plot(boax2, boay2, 'r-', label='PSA', lw = 3, visible = False)
        #ax2.plot(datax1, datay1, 'r-', label='PSA', lw = 3, visible = False)
        #ax2.set_yticks(ax2.get_yticks()[1:])

        if G140L:
            s = [y for x, y in zip(PSASegA[0][0], PSASegA[0][1]) if x > 1100. and x < 2000.]
            P.ylim(min(BOASegA[0][1]), max(s)*1.02)

        m = ax1.get_yticks()[1] - ax1.get_yticks()[0]
        yminorLocator = MultipleLocator(m/5)
        yminorFormattor = NullFormatter()
        ax1.yaxis.set_minor_locator(yminorLocator)
        ax1.yaxis.set_minor_formatter(yminorFormattor)      
        
        if G140L:
            P.xlim(940, 2140)
            xminorLocator = MultipleLocator(50)
            xminorFormattor = NullFormatter()
            ax1.xaxis.set_minor_locator(xminorLocator)
            ax1.xaxis.set_minor_formatter(xminorFormattor) 
        elif title == 'G230L':
            P.xlim(1000, 4000)
            xminorLocator = MultipleLocator(100)
            xminorFormattor = NullFormatter()
            ax1.xaxis.set_minor_locator(xminorLocator)
            ax1.xaxis.set_minor_formatter(xminorFormattor)
        else:
            xminorLocator = MultipleLocator(25)
            xminorFormattor = NullFormatter()
            ax1.xaxis.set_minor_locator(xminorLocator)
            ax1.xaxis.set_minor_formatter(xminorFormattor)
        if logy: ax1.set_yscale('log')

        ax1.set_yticks(ax1.get_yticks()[1:]) #deletes the lowest y axis tick!

        
        P.savefig(output+self.type)
        P.close()


    def Chapeter13Plots(self, datax1, datay1, boax2, boay2, title, output, G140L = False, logy = False):
        '''
        Plots the FUV point-source sensitivities for Chapter 13. Old method, still used for NUV.
        '''
        boaFactor = 100.
        
        ax1 = P.subplot(111)
        P.title(title)
        ax1.set_xlabel('Wavelength (\AA)')
        ax1.set_ylabel('counts pixel$^{-1}$ s$^{-1}$ / (erg s$^{-1}$ cm$^{-2}$ \AA$^{-1}$)')      
        ax1.plot(datax1, datay1, 'r-', label='PSA', lw = 3)
        ax1.plot(boax2, boaFactor*N.array(boay2), 'g--', label='BOA x %i' % int(boaFactor), lw = 3)
        ax1.legend(shadow = True)
        #ax2 = ax1.twinx()
        #ax2.set_ylabel('another axis (to be decided)')
        #ax2.yaxis.tick_right()
        #ax2.plot(boax2, boay2, 'r-', label='PSA', lw = 3, visible = False)
        #ax2.plot(datax1, datay1, 'r-', label='PSA', lw = 3, visible = False)
        ax1.set_yticks(ax1.get_yticks()[1:]) #deletes the lowest y axis tick!
        #ax2.set_yticks(ax2.get_yticks()[1:])
        
        m = ax1.get_yticks()[1] - ax1.get_yticks()[0]
        yminorLocator = MultipleLocator(m/5)
        yminorFormattor = NullFormatter()
        ax1.yaxis.set_minor_locator(yminorLocator)
        ax1.yaxis.set_minor_formatter(yminorFormattor)      
        
        if G140L:
            P.xlim(1000, 2140)
            xminorLocator = MultipleLocator(40)
            xminorFormattor = NullFormatter()
            ax1.xaxis.set_minor_locator(xminorLocator)
            ax1.xaxis.set_minor_formatter(xminorFormattor) 
        elif title == 'G230L':
            P.xlim(1200, 3300)
            xminorLocator = MultipleLocator(100)
            xminorFormattor = NullFormatter()
            ax1.xaxis.set_minor_locator(xminorLocator)
            ax1.xaxis.set_minor_formatter(xminorFormattor)
        else:
            xminorLocator = MultipleLocator(25)
            xminorFormattor = NullFormatter()
            ax1.xaxis.set_minor_locator(xminorLocator)
            ax1.xaxis.set_minor_formatter(xminorFormattor)
        if logy: ax1.set_yscale('log')
        P.savefig(output+self.type)
        P.close()
 
    def Chapter13Waves(self, data, grating, output):
        annosize = 'x-small'
        #FP = [1,2,3,4]
        FP = [4,3,2,1]
        G140L, G130MS, G130M = False, False, False
        
        ax = P.subplot(111)        
        P.ylabel('Central Wavelength (\AA)')
        P.xlabel('Wavelength (\AA)')
        
        for x in FP:
            tmp = data[data['fp-pos'] == x]
            for line in tmp:
                if line['grating'] == 'G140L':
                    shifty = -(x - 2.5)*8
                    shiftx = 90
                    G140L = True
                    xl = 180            
                elif line['grating'] == 'G130M':
                    shifty = -(x - 2.5)*1.9
                    shiftx = 20
                    xl = 1050
                    G130M = True
                elif line['grating'] == 'G130MS':
                    shifty = -(x - 2.5)*4
                    shiftx = 15
                    xl = 830
                    G130MS = True
                else:
                    shifty = -(x - 2.5)*1.8
                    shiftx = 20
                    xl = 1310
                    
                if line['segment'] == 'FUVA':
                    l1 = P.plot([line['start'],line['stop']], [line['central']+shifty,line['central']+shifty],
                           'r-', lw = 3)
                    P.annotate(str(int(round(line['stop']))),
                               xy = (line['stop'] + shiftx, line['central']+shifty), 
                               horizontalalignment='center',
                               verticalalignment='center',
                               size = annosize)
                    if G140L and line['central'] == 1105:
                        P.annotate(str(int(round(line['start']))),
                                   xy = (line['start'] - shiftx, line['central']+shifty), 
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)
                        P.annotate(line['fp-pos'],
                                   xy = (xl, line['central']+shifty),
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)
                else:
                    if G140L:
                        l3 = P.plot([300,900], [line['central']+shifty,line['central']+shifty],
                               'b-', lw = 3, alpha = 0.3)
                        l2 = P.plot([line['start'],line['stop']], [line['central']+shifty,line['central']+shifty],
                               'b-', lw = 3)
                        P.annotate(line['fp-pos'],
                                   xy = (xl, line['central']+shifty),
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)
                    else:
                        l2 = P.plot([line['start'],line['stop']], [line['central']+shifty,line['central']+shifty],
                               'b-', lw = 3)
                        P.annotate(str(int(round(line['start']))),
                                   xy = (line['start'] - shiftx, line['central']+shifty), 
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)
                        P.annotate(line['fp-pos'],
                                   xy = (xl, line['central']+shifty),
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)

        
        P.annotate('FP-POS',
                   xy = (0.07, 0.89),
                   horizontalalignment='center',
                   verticalalignment='center',
                   xycoords='axes fraction')        
        

        ymin, ymax = P.ylim()
        xmin, xmax = P.xlim()
        
        ax.set_yticks(data[(data['fp-pos'] == 1) & (data['segment'] == 'FUVA')]['central'])
        ax.set_ylim(ymin - 1, ymax + 8) 
        
        if G140L:
            ax.xaxis.set_minor_locator(MultipleLocator(500/5))
            ax.set_xlim(0, 2700)
            ax.set_ylim(ymin - 1, ymax + 50)
        elif G130MS:
            ax.xaxis.set_minor_locator(MultipleLocator(100/5))
            ax.set_xlim(800, 1280)
            ax.set_ylim(ymin, ymax + 5)
        elif G130M:
            ax.xaxis.set_minor_locator(MultipleLocator(100/5))
            ax.set_xlim(1020, 1520)
            #ax.set_ylim(ymin, ymax + 5)
              
        else:
            ax.xaxis.set_minor_locator(MultipleLocator(100/5))
            ax.set_xlim(xmin - 30, xmax + 15)
        
        P.legend((l1, l2), ('SEGMENT A', 'SEGMENT B'), shadow = True)
        P.savefig(output+self.type)
        P.close()        
 
    def Chapter13WavesOLD(self, data, grating, output):
        annosize = 'x-small'
        #FP = [1,2,3,4]
        FP = [4,3,2,1]
        G140L, G130M = False, False
        
        ax = P.subplot(111)        
        P.ylabel('Central Wavelength (\AA)')
        P.xlabel('Wavelength (\AA)')
        
        for x in FP:
            tmp = data[data['fp-pos'] == x]
            for line in tmp:
                if line['grating'] == 'G140L':
                    shifty = -(x - 2.5)*8
                    shiftx = 90
                    G140L = True
                    xl = 180            
                elif line['grating'] == 'G130M':
                    shifty = -(x - 2.5)*1.9
                    shiftx = 20
                    xl = 820
                    G130M = True
                    if line['central'] == 1055:
                        line['central'] += 205
                    if line['central'] == 1096:
                        line['central'] += 175
                else:
                    shifty = -(x - 2.5)*1.8
                    shiftx = 20
                    xl = 1310
                if line['segment'] == 'FUVA':
                    l1 = P.plot([line['start'],line['stop']], [line['central']+shifty,line['central']+shifty],
                           'r-', lw = 3)
                    P.annotate(str(int(round(line['stop']))),
                               xy = (line['stop'] + shiftx, line['central']+shifty), 
                               horizontalalignment='center',
                               verticalalignment='center',
                               size = annosize)
                    if G140L and line['central'] == 1105:
                        P.annotate(str(int(round(line['start']))),
                                   xy = (line['start'] - shiftx, line['central']+shifty), 
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)
                        P.annotate(line['fp-pos'],
                                   xy = (xl, line['central']+shifty),
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)
                else:
                    if G140L:
                        l3 = P.plot([300,900], [line['central']+shifty,line['central']+shifty],
                               'b-', lw = 3, alpha = 0.3)
                        l2 = P.plot([line['start'],line['stop']], [line['central']+shifty,line['central']+shifty],
                               'b-', lw = 3)
                        P.annotate(line['fp-pos'],
                                   xy = (xl, line['central']+shifty),
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)
                    else:
                        l2 = P.plot([line['start'],line['stop']], [line['central']+shifty,line['central']+shifty],
                               'b-', lw = 3)
                        P.annotate(str(int(round(line['start']))),
                                   xy = (line['start'] - shiftx, line['central']+shifty), 
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)
                        P.annotate(line['fp-pos'],
                                   xy = (xl, line['central']+shifty),
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)

        
        P.annotate('FP-POS',
                   xy = (0.07, 0.89),
                   horizontalalignment='center',
                   verticalalignment='center',
                   xycoords='axes fraction')        
        

        ymin, ymax = P.ylim()
        xmin, xmax = P.xlim()
        
        if G130M:
            tmp = [1055+205, 1096+175]
            for x in data[(data['fp-pos'] == 1) & (data['segment'] == 'FUVA')]['central']:
                if x > 1100:
                    tmp.append(x)
            ax.set_yticks(tmp)
            #t = [str(x) for x in data[(data['fp-pos'] == 1) & (data['segment'] == 'FUVA')]['central']]
            #ax.set_yticklabels(t)
            ax.set_yticklabels(['1055', '1096', '1291', '1300', '1309', '1318', '1327'])
        else:
            ax.set_yticks(data[(data['fp-pos'] == 1) & (data['segment'] == 'FUVA')]['central'])
            ax.set_ylim(ymin - 1, ymax + 8) 
        
        if G140L:
            ax.xaxis.set_minor_locator(MultipleLocator(500/5))
            ax.set_xlim(0, 2700)
            ax.set_ylim(ymin - 1, ymax + 50)
        elif G130M:
            ax.xaxis.set_minor_locator(MultipleLocator(100/5))
            ax.set_xlim(800, 1520)
            ax.set_ylim(ymin + 4, ymax + 12)            
        else:
            ax.xaxis.set_minor_locator(MultipleLocator(100/5))
            ax.set_xlim(xmin - 30, xmax + 15)
        
        P.legend((l1, l2), ('SEGMENT A', 'SEGMENT B'), shadow = True)
        P.savefig(output+self.type)
        P.close()         
 
    def Chapter13Wavelength(self, grating, offset, title, output, G140L = False):
        '''
        Plots the FUV wavelength ranges for given grating setting.
        '''
        
        annosize = 'x-small' # 'small'
        
        xoff = offset

        centwavs = []

        ax = P.subplot(111)
        
        for line in grating:
            centwavs.append(line[2])
            if line[0] == 'FUVB':
                if G140L:
                    for temp in line[4]:
                        if temp != 50 and temp >= 1104.5:
                            start = temp
                            break
                    if start < line[4][-1]:
                        a = P.plot([start, line[4][-1]], [line[2], line[2]],
                                   'b-',
                                   label=line[0],
                                   lw = 4)
                        P.annotate(str(int(round(start))),
                                   xy = (start - xoff, line[2]), 
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)
                    else:
                        P.annotate('1105',
                                   xy = (1105 - xoff, line[2]),
                                   horizontalalignment='center',
                                   verticalalignment='center',
                                   size = annosize)                        
                else:
                    a = P.plot([line[4][0], line[4][-1]], [line[2], line[2]],
                               'b-',
                               label=line[0],
                               lw = 4)
                    P.annotate(str(int(round(line[4][0]))),
                               xy = (line[4][0] - xoff, line[2]), 
                               horizontalalignment='center',
                               verticalalignment='center',
                               size = annosize)                
            if line[0] == 'FUVA':
                if G140L:
                    for temp in line[4]:
                        if temp != 50 and temp >= 1104.5:
                            start = temp
                            break
                    P.annotate(str(int(round(line[4][-1]))),
                               xy = (line[4][-1] + xoff, line[2]),
                               horizontalalignment='center',
                               verticalalignment='center',
                               size = annosize)
                    b = P.plot([start, line[4][-1]], [line[2], line[2]],
                               'r-',
                               label=line[0],
                               lw = 3)
                else:
                    b = P.plot([line[4][0], line[4][-1]], [line[2], line[2]],
                               'r-',
                               label=line[0],
                               lw = 4)
                    P.annotate(str(int(round(line[4][-1]))),
                               xy = (line[4][-1] + xoff + 1, line[2]), 
                               horizontalalignment='center',
                               verticalalignment='center',
                               size = annosize)            
        
        #P.title(title) #or with title??????????????????
        
        P.ylabel('Central Wavelength (\AA)')
        P.xlabel('Wavelength (\AA)')  
        ymin, ymax = P.ylim()
        xmin, xmax = P.xlim()
        P.xlim(xmin - 20, xmax + 20)
        P.ylim(ymin - 10, ymax + 10) 
        P.yticks(centwavs)
        if G140L:
            P.ylim(ymin - 170, ymax + 150)
            xminorLocator = MultipleLocator(100)
            #xmajorFormattor = FormatStrFormatter('%i')
            xminorFormattor = NullFormatter()
            ax.xaxis.set_minor_locator(xminorLocator)
            ax.xaxis.set_minor_formatter(xminorFormattor)
        else:
            xminorLocator = MultipleLocator(20)
            #xmajorFormattor = FormatStrFormatter('%i')
            xminorFormattor = NullFormatter()
            ax.xaxis.set_minor_locator(xminorLocator)
            ax.xaxis.set_minor_formatter(xminorFormattor)
        P.legend((b, a), ('FUVA', 'FUVB'), shadow = True) #, loc='lower right') #, fancybox = True)    
        
        for tick in ax.yaxis.get_major_ticks():
            tick.label1.set_fontsize(10)
        for tick in ax.xaxis.get_major_ticks():
            tick.label1.set_fontsize(10)
        
        P.savefig(output+self.type)
        P.close()

    
    def Chapter13WavelengthOLD(self, grating, offset, title, output, G140L = False):
        '''
        Plots the FUV wavelength ranges for given grating setting.
        '''
        x = 0.09 + offset[0]
        y = 0.21 + offset[1]
        xG, yG = 0.07, 0.383
        tmp, extr = 1, 0
        centwavs = []

        ax = P.subplot(111)
        
        for line in grating:
            tmp +=1
            if tmp % 2 == 0:
                if G140L:
                    for temp in line[4]:
                        if temp != 50 and temp >= 1104.5:
                            start = temp
                            break
                    a = P.plot([start, line[4][-1]], [line[2], line[2]],
                               'b-',
                               label=line[0],
                               lw = 4)
                    P.annotate(str(int(round(line[4][-1]))),
                               xy = (xG + 0.73 + extr, yG), 
                               xycoords='axes fraction',
                               horizontalalignment='center',
                               verticalalignment='center')
                    extr += 0.08
                else:
                    a = P.plot(line[4], [line[2] for dummy in xrange(len(line[4]))],
                               'b-',
                               label=line[0],
                               lw = 4)
                    P.annotate(str(int(round(line[4][-1]))),
                               xy=(x+0.72 + offset[2], y),  
                               xycoords='axes fraction',
                               horizontalalignment='center',
                               verticalalignment='center')
                centwavs.append(line[2])
            else:
                if G140L:
                    P.annotate('1105',
                               xy = (xG, yG),
                               xycoords='axes fraction',
                               horizontalalignment='center',
                               verticalalignment='center')
                    if line[4][-1] > 1104.5:
                        b = P.plot([1104.5, line[4][-1]], [line[2], line[2]],
                                   'r-',
                                   label=line[0],
                                   lw = 3)
                else:
                    b = P.plot(line[4], [line[2] for dummy in xrange(len(line[4]))],
                               'r-',
                               label=line[0],
                               lw = 3)
                    P.annotate(str(int(round(line[4][0]))),
                               xy=(x, y),
                               xycoords='axes fraction',
                               horizontalalignment='center',
                               verticalalignment='center')
                y += 0.15 + offset[3]
                x += 0.023 + offset[4]
                yG += 0.282

        P.title(title)
        P.ylabel('Central Wavelength (\AA)')
        P.xlabel('Wavelength (\AA)')  
        ymin, ymax = P.ylim()
        xmin, xmax = P.xlim()
        P.xlim(xmin - 20, xmax + 20)
        P.ylim(ymin - 10, ymax + 10) 
        P.yticks(centwavs)
        if G140L:
            P.xlim(1000, xmax + 100)
            P.ylim(ymin - 150, ymax + 150)         
        else:
            P.xlim(xmin - 20, xmax + 20)
            P.ylim(ymin - 10, ymax + 10) 
            xminorLocator = MultipleLocator(20)
            xminorFormattor = NullFormatter()
            ax.xaxis.set_minor_locator(xminorLocator)
            ax.xaxis.set_minor_formatter(xminorFormattor)
        P.legend((b, a), ('FUVA', 'FUVB'), shadow = True, loc='upper left') #, fancybox = True)    
        P.savefig(output+self.type)
        P.close()

    def Chapter13WavelengthNUVNew(self, data, outputpath):
        '''
        Plots the FUV wavelength ranges for given grating setting.
        '''
        shift = 55.
        length = 1023.
        lsq = length**2
        
        annosize = 'x-small' # 'small'
        xminorFormattor = NullFormatter()

        #all gratings in data
        gratings = set([x[1] for x in data])

        for g in gratings:
            tmp = [[line[0], line[2], line[3]] for line in data if line[1] == g]
            centwavs = [x for x in set([line[1] for line in tmp])]
            #use the dispersion solution to calculate the wavelength ranges
            d = [[a, b,
                  [c[0], c[0] + length*c[1] + lsq*c[2], 
                   c[0] - shift*c[1],
                   c[0] + 2.*shift*c[1] + length*c[1] + lsq*c[2]]]
                   for a,b,c in tmp]
           
            ax = P.subplot(111)

            for line in d:
                def_range = [line[2][0], line[2][1]]
                ext_range = [line[2][2], line[2][3]]
                y = [line[1], line[1]]
                print '%s %5i %s %6.0f %6.0f %5.2f' % (g, line[1], line[0], def_range[0], def_range[1], def_range[0] - ext_range[0])
                if 'NUVA' in line[0]:
                    ax.plot(ext_range, y ,'b-',
                            lw = 4,
                            alpha = 0.4)
                    a = ax.plot(def_range, y ,'b-',
                                label = line[0],
                                lw = 4,
                                alpha = 0.9)
                if 'NUVB' in line[0]:
                    ax.plot(ext_range, y ,'g-',
                            lw = 4,
                            alpha = 0.4)
                    b = ax.plot(def_range, y ,'g-',
                                label = line[0],
                                lw = 4,
                                alpha = 0.9)
                if 'NUVC' in line[0]:
                    if 'G230L' in g:
                        ax.plot(ext_range, N.array(y) + 10,'r-',
                                lw = 4,
                                alpha = 0.4)
                        c = ax.plot(def_range, N.array(y) + 10,'r-',
                                    label = line[0],
                                    lw = 4,
                                    alpha = 0.9)
                    else:                    
                        ax.plot(ext_range, y ,'r-',
                                lw = 4,
                                alpha = 0.4)
                        c = ax.plot(def_range, y ,'r-',
                                    label = line[0],
                                    lw = 4,
                                    alpha = 0.9)

            ax.set_ylabel('Central Wavelength (\AA)')
            ax.set_xlabel('Wavelength (\AA)')
            ax.legend((a, b, c), ('NUVA', 'NUVB', 'NUVC'), shadow = True, loc='upper left') 
            ax.set_yticks(centwavs)
        
            if 'G230L' in g:
                xminorLocator = MultipleLocator(100)
                ax.xaxis.set_minor_locator(xminorLocator)
                ax.xaxis.set_minor_formatter(xminorFormattor)   
                P.xlim(900., 4000.)
                P.ylim(2500., 3500.)
            else:
                xminorLocator = MultipleLocator(20)
                ax.xaxis.set_minor_locator(xminorLocator)
                ax.xaxis.set_minor_formatter(xminorFormattor)                   
            
            if 'G285' in g:
                P.ylim(2600., 3110.)
                P.xlim(2380., 3320.)
            
            for tick in ax.yaxis.get_major_ticks():
                tick.label1.set_fontsize(10)
            for tick in ax.xaxis.get_major_ticks():
                tick.label1.set_fontsize(10)
            
            P.savefig(outputpath + g + 'Wave' + self.type)
            P.close()


    def Chapter13WavelengthNUV(self, grating, xoffset, title, output):
        '''
        Plots the FUV wavelength ranges for given grating setting.
        '''

        annosize = 'x-small' # 'small'

        G230 = False
        G285 = False
        
        xminorFormattor = NullFormatter()
        
        centwavs = []
        xoff = xoffset

        ax = P.subplot(111)
        
        #('NUVC', 'G230L', 2950, 'PSA', WAVE, SENS)
        for line in grating:
            centwavs.append(line[2])
            if line[1] == 'G285M': G285 = True
            if line[1] == 'G230L': G230 = True
            if line[0] == 'NUVA':
                a = P.plot([line[4][0], line[4][-1]], [line[2], line[2]],
                           'b-',
                           label=line[0],
                           lw = 4)
                if line[1] == 'G230L':
                    P.annotate(str(int(round(line[4][0]))),
                               xy = (line[4][0] - xoff - 85, line[2]), 
                               horizontalalignment='center',
                               verticalalignment='center',
                               size = annosize)                                  
                else:
                    P.annotate(str(int(round(line[4][0]))),
                               xy = (line[4][0] - xoff, line[2]), 
                               horizontalalignment='center',
                               verticalalignment='center',
                               size = annosize)           
            if line[0] == 'NUVB':
                if G230:
                    if line[4][-1] > 3200:
                        b = P.plot([line[4][0], line[4][-1]], [line[2], line[2]],
                               'g-',
                               label=line[0],
                               lw = 4,
                               alpha = 0.5)
                        b = P.plot([line[4][0], 3200], [line[2], line[2]],
                               'g-',
                               label=line[0],
                               lw = 4)
                    else:
                        b = P.plot([line[4][0], line[4][-1]], [line[2], line[2]],
                               'g-',
                               label=line[0],
                               lw = 4)
                    P.annotate(str(int(round(line[4][-1]))),
                               xy = (line[4][-1] + xoff + 90, line[2]), 
                               horizontalalignment='center',
                               verticalalignment='center',
                               size = annosize)
                else:
                    b = P.plot([line[4][0], line[4][-1]], [line[2], line[2]],
                           'g-',
                           label=line[0],
                           lw = 4)
            if line[0] == 'NUVC':
                c = P.plot([line[4][0], line[4][-1]], [line[2], line[2]],
                           'r-',
                           label=line[0],
                           lw = 4,
                           zorder = 20)
                if line[1] != 'G230L':
                    P.annotate(str(int(round(line[4][-1]))),
                               xy = (line[4][-1] + xoff + 4, line[2]), 
                               horizontalalignment='center',
                               verticalalignment='center',
                               size = annosize)
        
        #P.title(title)
        P.ylabel('Central Wavelength (\AA)')
        P.xlabel('Wavelength (\AA)')
        P.legend((a, b, c), ('NUVA', 'NUVB', 'NUVC'), shadow = True, loc='upper left') 
        P.yticks(centwavs)

        
        if G230:
            xminorLocator = MultipleLocator(100)
            ax.xaxis.set_minor_locator(xminorLocator)
            ax.xaxis.set_minor_formatter(xminorFormattor)   
            P.xlim(900., 4000.)
            P.ylim(2500., 3500.)
        else:
            xminorLocator = MultipleLocator(20)
            ax.xaxis.set_minor_locator(xminorLocator)
            ax.xaxis.set_minor_formatter(xminorFormattor)                   
        
        if G285:
            P.ylim(2600., 3110.)
            P.xlim(2380., 3320.)
        
        for tick in ax.yaxis.get_major_ticks():
            tick.label1.set_fontsize(10)
        for tick in ax.xaxis.get_major_ticks():
            tick.label1.set_fontsize(10)
        
        P.savefig(output+self.type)
        P.close()


    def FUVsensitivityBOA(self, datax1, datay1, datax2, datay2, datax3, datay3, output):
        '''
        Plots the FUV BOA point-source sensitivities for three gratings.
        '''    
        ax = P.subplot(111)
        P.title('FUV BOA point-source sensitivities')
        P.xlabel('Wavelength (\AA)')
        P.ylabel('counts resel$^{-1}$ sec$^{-1}$ per FEFU')      
        P.plot(datax1, datay1, 'b-', label='G130M', lw = 3)
        P.plot(datax2, datay2, 'r-', label='G140L', lw = 3)
        P.plot(datax3, datay3, 'g-', label='G160M', lw = 3)
        P.legend(shadow = True)
        P.xlim(1077., 2140.)
        
        #limits the y axis between realistic values
        s = [y for x, y in zip(datax2, datay2) if x > 1100. and x < 2000]
        P.ylim(-0.0000001, max(s)*1.05)

        xminorLocator = MultipleLocator(50)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)
        P.ylim()
        P.savefig(output+self.type)
        P.close()
    
    def NUVsensitivity(self, G185, G225, G285, G230, output):
        '''
        Plots NUV point-source sensitivities in units of effective area
        and throughput.
        '''
        ar = 45238.93416 #HST primary area in cm**2
        split = 3255 #3250
        every = 3
        
        ax = P.subplot(111)
        #P.title('FUV point-source sensitivities')

        ax2 = ax.twinx()

        G230L2ndX = [line[0] for line in G230 if (line[0] > 1700 and line[0] < 2600 and line[1] < 200)]
        G230L2ndY = [line[1] for line in G230 if (line[0] > 1700 and line[0] < 2600 and line[1] < 200)]
            
        G230LX, G230LY = Fix(G230)

        ax2.plot([line[0] for line in G185][::every], N.array([line[1] for line in G185][::every])/ar, 'b-', label='G185M')
        ax2.plot([line[0] for line in G225][::every], N.array([line[1] for line in G225][::every])/ar, 'g-', label='G225M')
        ax2.plot([line[0] for line in G285][::every], N.array([line[1] for line in G285][::every])/ar, 'r-', label='G285M')
        ax2.plot(G230LX[G230LX < split], N.array(G230LY[G230LX < split])/ar, 'm-', label='G230L')
        #ax2.plot(G230L2ndX, N.array(G230L2ndY)/ar, 'm:', label='G230L 2nd-order')
        #ax2.plot([line[0] for line in G230 if line[0] >= split], N.array([line[1] for line in G230 if line[0] >= split])/ar, 'm:')

        ax.plot([line[0] for line in G185][::every], [line [1] for line in G185][::every], 'b-', label='G185M', lw = 3)
        ax.plot([line[0] for line in G225][::every], [line [1] for line in G225][::every], 'g-', label='G225M', lw = 3)
        ax.plot([line[0] for line in G285][::every], [line [1] for line in G285][::every], 'r-', label='G285M', lw = 3)
        ax.plot(G230LX[G230LX < split], G230LY[G230LX < split], 'm-', label='G230L', lw = 3)
        #ax.plot(G230L2ndX, G230L2ndY, 'm:', label='G230L 2nd-order', lw = 3)
        #ax2.plot([line[0] for line in G230 if line[0] >= split], [line[1] for line in G230 if line[0] >= split], 'm:')

        s = [y for x, y in G230 if x > 2000. and x < 3000.]
        ax.set_ylim(-0.0001, max(s)*1.05)
        ax2.set_ylim(-0.0001, max(s)*1.05/ar)

        ax.set_xlim(1200., 3300.)
        ax2.set_xlim(1200., 3300.)

        ax.set_xlabel('Wavelength (\AA)')
        ax.set_ylabel('Effective Area (cm$^{2}$)') 
        ax2.set_ylabel('Fractional Throughput') 
        
        xminorLocator = MultipleLocator(500/5)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)

        ax.yaxis.set_minor_locator(MultipleLocator(100/5))
        ax2.yaxis.set_minor_locator(MultipleLocator(0.005/5))

        P.legend(shadow = True)
        P.savefig(output+self.type)
        P.close()
        
    def NUVsensitivityM(self, datax1, datay1, datax2, datay2, datax3, datay3, output):
        '''
        Plots NUV point-source sensitivities for M gratings.
        Corresponds to Figure 5.3 on page 41 at the first COS instrument handbook.
        '''              
        ax = P.subplot(111)
        P.title('NUV point-source sensitivities: M gratings')
        P.xlabel('Wavelength (\AA)')
        P.ylabel('counts resel$^{-1}$ sec$^{-1}$ per FEFU')    
        P.plot(datax1, datay1, 'b-', label='G185M', lw = 3)
        P.plot(datax2, datay2, 'g-', label='G225M', lw = 3)
        P.plot(datax3, datay3, 'r-', label='G285M', lw = 3)
        P.legend(shadow = True)
        P.xlim(1500., 3400.)
        P.ylim(-0.0001, 0.01)
        xminorLocator = MultipleLocator(100)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)
        P.savefig(output+self.type)
        P.close()

    def NUVsensitivityG230L(self, datax, datay, output):
        '''
        Plots NUV point-source sensitivities for grating G230L.
        Corresponds to Figure 5.4 on page 41 at the first COS instrument handbook.
        '''

        ax = P.subplot(111)        
        P.title('NUV point-source sensitivity: G230L')
        P.xlabel('Wavelength (\AA)')
        P.ylabel('counts resel$^{-1}$ sec$^{-1}$ per FEFU')     
        P.plot(datax, datay, 'r-', label='G230L', lw = 3)
        P.legend(shadow = True)
        P.xlim(1000., 4000.)
        xminorLocator = MultipleLocator(100)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)
        P.savefig(output+self.type)
        P.close()
        
    def NUVFlatField(self, datax, datay, yline, output, smooth = False, smoothing = (20,)):
        '''
        Plots the NUV MAMA flat field.
        Corresponds to Figure 5.6 on page 53 at the first COS instrument handbook.
        '''
        P.title('NUV Flat Field')
        P.xlabel('x (pixels)')
        P.ylabel('Normalized Counts')
        P.plot(datax, datay, 'k-', label = 'Profile', lw=1)
        if smooth:
            try:
                import scipy.stsci.convolve as C
            except:
                import convolve as C
            smoothed = C.boxcar(N.array(datay), smoothing)
            P.plot(datax, smoothed, 'r-', label='Boxcar smoothed', lw=1)
        P.xlim(0, len(datay)+1)
        P.ylim(0.8, 1.2)
        P.legend(shadow = True)
        P.savefig(output+self.type)
        P.close()

    def FUVFlatField(self, datax, datay, yline, output, smooth = False, smoothing = (50,)):
        '''
        Plots the NUV MAMA flat field.
        Corresponds to Figure 5.6 on page 53 at the first COS instrument handbook.
        '''
        P.title('FUV Flat Field')
        P.xlabel('x (pixels)')
        P.ylabel('Normalized Counts')
        P.plot(datax, datay, 'k-', label='Profile', lw=1)
        if smooth:
            try:
                import scipy.stsci.convolve as C
            except:
                import convolve as C
            smoothed = C.boxcar(N.array(datay), smoothing)
            P.plot(datax, smoothed, 'r-', label = 'Boxcar smoothed', lw=1)
        P.xlim(0, len(datay)+1)
        P.ylim(0.1, 1.9)
        P.legend(shadow = True)
        P.savefig(output+self.type)
        P.close()

    def PSAMMIRRORANUVImaging(self, datax, datay, output):
        '''
        Test function to plot cross section through and image.
        '''
        P.title('PSA imaging with MIRRORA')
        P.xlabel('y (pixels)')
        P.ylabel('Counts')
        P.plot(datax, datay, 'r-', lw=3)
        P.xlim(175., 225.)
        P.savefig(output+self.type)
        P.close()

    def COSFUVSpectrumDev2(self, imagedata, wave, counts, exptime, output):
        '''
        Plots an example of a COS FUV spectrum with annotate.
        A bug in matplotlib version of STScI installation prevents using this... 
        '''
        xlow = 800
        xhigh = 15000
        
        fig = P.figure(1, figsize=(8,5))
        
        P.title('Segment B, G160M, 1600 \AA, %i seconds' % exptime)
        P.subplots_adjust(hspace = 0.0)
        P.setp(P.gca(), xticklabels=[], yticklabels=[])
        
        ax1 = fig.add_subplot(211, autoscale_on=False)
        ax1.imshow(imagedata, cmap=cm.gist_yarg, vmin=N.min(imagedata), 
                   vmax = N.max(imagedata) / exptime, origin = 'lower', aspect = 'auto',
                   interpolation='nearest')
        ax1.annotate('WCA', xy = (4000., 540.), xycoords = 'data',
                        xytext = (-50, 30), textcoords = 'offset points',
                        arrowprops = dict(arrowstyle="->",
                        connectionstyle = "angle,angleA=0,angleB=90,rad=10"))
        ax1.set_ylabel('Y pixels')
        ax1.set_ylim(450.,600.)
        ax1.set_xlim(xlow, xhigh)
        P.setp(P.gca(), xticklabels=[])
        
        ax2 = fig.add_subplot(212)   
        ax2.plot(wave, exptime * counts, 'k-')
        ax2.set_ylabel('Counts')
        ax2.set_xlabel('x pixels')
        ax2.set_xlim(xlow, xhigh)
        ax2.set_ylim(0., exptime * N.max(counts)*1.1)
        P.savefig(output+self.type)        
        P.close() 

    
    def COSFUVSpectrum(self, imagedata, wave, counts, exptime, output):
        '''
        Plots an example of a COS FUV spectrum.
        Corresponds to Figure 4.2 on page 29 at the first COS instrument handbook.
        '''
        xlow = 800
        xhigh = 15000
        
        P.title('Segment B, G160M, 1600 \AA, %i seconds' % exptime)
        P.subplots_adjust(hspace = 0.0)
        P.setp(P.gca(), xticklabels=[], yticklabels=[])
        
        ax1 = P.subplot(211, autoscale_on=False)
        ax1.imshow(imagedata, cmap=cm.gist_yarg, vmin=N.min(imagedata), 
                   vmax = N.max(imagedata) / exptime, origin = 'lower', aspect = 'auto',
                   interpolation='nearest')
        ax1.set_ylabel('Y pixels')
        ax1.set_ylim(450.,600.)
        ax1.set_xlim(xlow, xhigh)
        P.setp(P.gca(), xticklabels=[])
        
        ax2 = P.subplot(212)   
        ax2.plot(wave, exptime * counts, 'k-')
        ax2.set_ylabel('Counts')
        ax2.set_xlabel('x pixels')
        ax2.set_xlim(xlow, xhigh)
        ax2.set_ylim(0., exptime * N.max(counts)*1.1)
        P.savefig(output+self.type)        
        P.close() 
        
    def WavecalSpecPSA(self, wave, countss, output):
        '''
        Plots and example wavecal spectrum of PSA FUV.
        Corresponds to Figures 13.3 and 13.4 on page 138 of the fist COS instrument handbook.
        '''  
        P.title('G140L PSA')
        P.plot(wave, countss, 'k-')
        #P.xlabel('Wavelength (\AA)')
        P.xlabel('x (pixels)')
        P.ylabel('Counts per second')
        P.plot(wave, countss, 'k-')
        P.xlim(2000, 12000)
        inset = P.axes([.6, .65, .25, .2])
        P.plot(wave, countss, 'k-')
        P.setp(inset, xlim=(4600, 4700)) #, xticks=[], yticks=[])
        P.savefig(output+self.type)
        P.close()
    
    def MIRRORB(self, datax, datay, output):
        '''
        Plots the cross-section of a point-source image with MIRRORB.
        Corresponds to Figure 7.4 on page 73 at the first COS instrument handbook.
        '''
        ax = P.subplot(111)
        
        P.title('Point-source image with MIRRORB')
        P.xlabel('x (pixels)')
        P.ylabel('Counts')
        P.plot(datax, datay, 'r-')
        P.xlim(280, 340)
        P.ylim(-10, max(datay) + 30)
        
        xminorLocator = MultipleLocator(10./5.)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)

        yminorLocator = MultipleLocator(200/5)
        yminorFormattor = NullFormatter()
        ax.yaxis.set_minor_locator(yminorLocator)
        ax.yaxis.set_minor_formatter(yminorFormattor)
        
        P.savefig(output+self.type)
        P.close()
        
    def BOAprofile(self, datax, datay, output):
        '''
        Plots the cross-section through an image obtained with the BOA.
        Corresponds to Figure 7.5 on page 74 at the first COS instrument handbook.
        '''
        ax = P.subplot(111)
        P.title('BOA image profile')
        P.xlabel('x (pixels)')
        P.ylabel('Relative Counts')
        P.plot(datax, datay, 'r-')

        #P.xlim(280, 340)
        P.ylim(-1, max(datay) + 3)

        xminorLocator = MultipleLocator(5./5.)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)
        
        yminorLocator = MultipleLocator(1)
        yminorFormattor = NullFormatter()
        ax.yaxis.set_minor_locator(yminorLocator)
        ax.yaxis.set_minor_formatter(yminorFormattor)        
        
        P.savefig(output+self.type)
        P.close()
        
    def BOAMIRRORprofile(self, dataxx, dataxy, datayx, datayy, output):
        '''
        Plots the cross-section through an image obtained with the BOA + MIRRORB in both x and y direction.
        Corresponds to Figs. 7.6 and 7.7 on page 75 at the first COS instrument handbook.
        '''
  
        #profile in x
        ax = P.subplot(111)
        
        P.title('BOA + MIRRORB profile in x')
        P.xlabel('x (pixels)')
        P.ylabel('Relative Counts')
        P.plot(dataxx, dataxy, 'r-')

        P.ylim(-1, max(dataxy) + 3)
        P.xlim(min(dataxx)+1, max(dataxx)-1)

        xminorLocator = MultipleLocator(20/5)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)

        yminorLocator = MultipleLocator(2.5)
        yminorFormattor = NullFormatter()
        ax.yaxis.set_minor_locator(yminorLocator)
        ax.yaxis.set_minor_formatter(yminorFormattor) 
                    
        P.savefig(output + '_x' + self.type)        
        P.close()
        
        #profile in y
        ax = P.subplot(111)
        
        P.title('BOA + MIRRORB profile in y')
        P.xlabel('y (pixels)')
        P.ylabel('Relative Counts')
        P.plot(datayx, datayy, 'r-')

        P.ylim(-1, max(datayy) + 3)
        P.xlim(min(datayx)+1, max(datayx)-1)

        xminorLocator = MultipleLocator(20/5)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)

        yminorLocator = MultipleLocator(2.5)
        yminorFormattor = NullFormatter()
        ax.yaxis.set_minor_locator(yminorLocator)
        ax.yaxis.set_minor_formatter(yminorFormattor)
        
        P.savefig(output + '_y' + self.type)
        P.close()
        
    def BOATransmission(self, datax, datay, every, output):
        '''
        Plots transmission of the COS BOA as a function of wavelength.
        Corresponds to Fig. 3.4 on page 14 of the first COS instrument handbook.
        '''
        ax = P.subplot(111)
        P.title('BOA transmission')
        P.xlabel('Wavelength (\AA)')
        P.ylabel('BOA transmission')
        P.plot(datax[::every], datay[::every], 'ro')
        P.xlim(1000, 3050)
        P.ylim(0.003, 0.01)
        xminorLocator = MultipleLocator(100)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)
        P.savefig(output+self.type)
        P.close()

    def ScatteredLight(self, datax, datay, output):
        '''
        Plots the scattered light in the FUV.
        Corresponds to Fig. 5.1 on page 39 at the first COS instrument handbook.
        '''
        P.title('Segment A, G130M, 1309 A, 300 seconds')
        P.xlabel('x (pixels)')
        P.ylabel('Counts')
        P.plot(datax, datay, 'k-')
        P.xlim(0, 17000)
        inset = P.axes([.6, .6, .27, .25])
        P.plot(datax, datay, 'k-')
        P.setp(inset, xlim=(5500, 6600), xticks = [5500, 6000, 6500])
        P.savefig(output+self.type)
        P.close()
        
    def NUVPSAImagingSensitivity(self, datax, datay, output):
        '''
        Plots the sensitivity curve for COS NUV imaging with the PSA.
        Corresponds to Fig. 6.1 on page 61 at the first COS instrument handbook.
        '''
        ar = 45238.93416
        
        ax = P.subplot(111)      
        #P.title('System Throughput for NUV Imaging')
        P.xlabel('Wavelength (\AA)')
        #P.ylabel('counts \AA$^{-1}$ per FEFU')
        #P.ylabel('Throughput')
        P.ylabel('Effective Area (cm$^{-2}$)')
        P.plot(datax, N.array(datay)*ar, 'r-', lw = 3)
        P.xlim(1400, 3700)
        
        xminorLocator = MultipleLocator(100)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)

        yminorLocator = MultipleLocator(200/5.)
        yminorFormattor = NullFormatter()
        ax.yaxis.set_minor_locator(yminorLocator)
        ax.yaxis.set_minor_formatter(yminorFormattor) 
        
        P.savefig(output+self.type)
        P.close()
        
    def NUVImageProfile(self, xpixels, counts, output):
        '''
        Plots NUV imaging profile for COS.
        Corresponds to Fig. 6.3 on page 63 at the first COS instrument handbook.
        '''
        ax = P.subplot(111) 
        P.title('NUV image profile')
        P.xlabel('x (pixels)')
        P.ylabel('Counts')
        P.plot(xpixels, counts, 'r-', lw = 3)
        #P.semilogy(xpixels, counts, 'r-', lw = 3)
        #P.axhline(0)
        P.xlim(477, 495)
        P.ylim(-1, max(counts)+5)

        xminorLocator = MultipleLocator(1)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor)
        
        yminorLocator = MultipleLocator(10/5)
        yminorFormattor = NullFormatter()
        ax.yaxis.set_minor_locator(yminorLocator)
        ax.yaxis.set_minor_formatter(yminorFormattor)         
        
        P.savefig(output+self.type)
        P.close()        
        
        
    def PSARelativeTransmission(self, datax, datay, output):
        '''
        Plots the relative transmission of the COS PSA at 1450A.
        Corresponds to Fig. 7.1 on page 69 at the first COS instrument handbook.
        '''
        ax = P.subplot(111) 
        #P.title('Relative throughput of PSA at 1450 \AA')
        P.xlabel('r (arcsec)')
        P.ylabel('relative flux')
        P.plot(datax, datay, 'r-', lw = 3)
        P.xlim(-2., 2.)
        xminorLocator = MultipleLocator(0.1)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor) 
        yminorLocator = MultipleLocator(0.04)
        yminorFormattor = NullFormatter()
        ax.yaxis.set_minor_locator(yminorLocator)
        ax.yaxis.set_minor_formatter(yminorFormattor) 
        P.savefig(output+self.type)
        P.close()        
    
    def PSF(self, datax, datay, dataz, output):
        '''
        Does not do very good job with matplotlib 0.99.0.
        The labels are somewhat tilted respect to the axis.
        '''
        fig = plt.figure()
        ax = Axes3D(fig)
        X, Y = N.meshgrid(datax, datay)
        ax.plot_surface(X, Y, dataz, rstride=1, cstride=1, cmap=cm.gray) #cm.gist_gray)
        #ax.plot_wireframe(X, Y, dataz, rstride=1, cstride=1)
        ax.set_xlabel('X Pixels')
        ax.set_ylabel('Y Pixels')
        ax.set_zlabel('Counts / s')
        P.savefig(output+self.type)
        P.close()                
    
    def PSFObsolete(self, data, output):
        '''
        Surface plotting with Gnuplot. Output is horrible... do NOT use!
        '''
        g = Gnuplot.Gnuplot()
        g.clear()
        g('set ticslevel 0')
        g.xlabel('x (pixels)')
        g.ylabel('y (pixels)')
        g('set zlabel \"counts\"')
        g('set surface')
        g('set style data lines')
        #g('set dgrid3d 10,10')
        g('set view 60,75')
        #g('set hidden3d')
        g.splot(data)
        g.hardcopy(filename=output + '.ps',terminal="postscript")
        
    def LSFcomparison(self, data, waves, title, output):
        '''
        Line Spread Function Comparison plots for Chapter 13.
        '''
        from mpl_toolkits.axes_grid.inset_locator import zoomed_inset_axes
        from mpl_toolkits.axes_grid.inset_locator import mark_inset
        
        limites = 41
        
        ax = P.subplot(111)
        
        cols = data.shape[1]
        
        for i in range(1,cols):
            if i < 8:
                P.plot(data[:,0], data[:,i], label = waves[i-1] + '\AA', lw = 0.5)
            elif i >= 8 and i < 14:
                P.plot(data[:,0], data[:,i], label = waves[i-1] + '\AA', lw = 0.5, ls = ':')
            else:
                P.plot(data[:,0], data[:,i], label = waves[i-1] + '\AA', lw = 0.5, ls = '-.')
        
        P.title(title)
        P.xlabel('Displacement (pixels)')
        P.ylabel('Normalized Intensity')
        P.xlim(-limites, limites)
        P.legend(shadow=True)

        xminorLocator = MultipleLocator(10./5.)
        xminorFormattor = NullFormatter()
        ax.xaxis.set_minor_locator(xminorLocator)
        ax.xaxis.set_minor_formatter(xminorFormattor) 
        if len(waves) < 14: yminorLocator = MultipleLocator(0.02/5.)
        else : yminorLocator = MultipleLocator(0.05/5.)
        yminorFormattor = NullFormatter()
        ax.yaxis.set_minor_locator(yminorLocator)
        ax.yaxis.set_minor_formatter(yminorFormattor) 

        #inset
        #axins = zoomed_inset_axes(ax, 3.4, loc=2)
        #for i in range(1,cols):
        #    if i < 8:
        #        axins.plot(data[:,0], data[:,i], label = waves[i-1] + '\AA', lw = 0.5)
        #    elif i >= 8 and i < 14:
        #        axins.plot(data[:,0], data[:,i], label = waves[i-1] + '\AA', lw = 0.5, ls = ':')
        #    else:
        #        axins.plot(data[:,0], data[:,i], label = waves[i-1] + '\AA', lw = 0.5, ls = '-.')       
        #if 'NUV' in title:
        #    axins.set_xlim(-4.0, 4.0)
        #    #axins.set_xlim(-1., 1.)
        #else:
        #    axins.set_xlim(-3.8, 3.8)
        #    #axins.set_xlim(-2.5, 2.5)
        #axins.set_ylim(max(data[:,i])-max(data[:,i])/7., max(data[:,i])+max(data[:,i])/110.)
        #mark_inset(ax, axins, loc1=1, loc2=4, fc='none', ec='0.5')

        #axins.set_xticks([100,])
        #axins.set_yticks([0,])
        
        #P.xticks(visible=False)
        #P.yticks(visible=False)
               
        #inset2
        axins2 = zoomed_inset_axes(ax, 5.1, loc=2)
        for i in range(1,cols):
            if i < 8:
                axins2.plot(data[:,0], data[:,i], label = waves[i-1] + '\AA', lw = 0.5)
            elif i >= 8 and i < 14:
                axins2.plot(data[:,0], data[:,i], label = waves[i-1] + '\AA', lw = 0.5, ls = ':')
            else:
                axins2.plot(data[:,0], data[:,i], label = waves[i-1] + '\AA', lw = 0.5, ls = '-.')       
        if 'NUV' in title:
            axins2.set_xlim(-9., -2.2)
            axins2.set_ylim(min(data[:,i])+max(data[:,i])/100., min(data[:,i])+max(data[:,i])/8.)
        else:
            axins2.set_xlim(-13.5, -7)
            axins2.set_ylim(min(data[:,i])+max(data[:,i])/30., min(data[:,i])+max(data[:,i])/8.)
       
        mark_inset(ax, axins2, loc1=1, loc2=3, fc='none', ec='0.5')  

        #axins2.set_xticks([100,])
        #axins2.set_yticks([0,])
        axins2.set_xticks([])
        axins2.set_yticks([])

        P.xticks(visible=False)
        P.yticks(visible=False)
        
        P.savefig(output+self.type)
        P.close()         
        
    def AcqImageExposureTimes(self, data, output):
        '''
        Fig. 7.3. in the COS IHB, version 1.0, page 72.
        '''
        ax = P.subplot(111)      
          
        ax.set_xlabel('Target flux (erg cm$^{-2}$ sec$^{-1}$ \AA$^{-1}$)')
        ax.set_ylabel('Exposure time (sec)')        
        
        for line in data:
            ax.plot(N.array(line[0])*10**-15, line[1], line[2], label = line[3])
        
        ax.set_xscale('log')
        ax.set_yscale('log')
        
        ax.set_ylim(5,1000)
        ax.set_xlim(10**-17, 10**-10)
        
        #ax.xaxis.set_major_formatter(FormatStrFormatter('%5.0f'))
        ax.yaxis.set_major_formatter(FormatStrFormatter('%i'))
        
        ax.legend(shadow = True)        
        
        P.savefig(output+self.type)
        P.close()
    
    def SpatialProfileFUV(self, corrtag_data, disp, xvalues, width, ymin, ymax, extr, ewidth, title, output):            
        def WfP(pix, disp):
            return disp[0] + (pix*disp[1]) + (pix*pix*disp[2])

        #manipulates arguments
        x1, x2, x3 = xvalues         
        ran = (ymin, ymax)
        wave1, wave2, wave3 = WfP(x1, disp), WfP(x2, disp), WfP(x3, disp)
        
        #gets the data from corrtag
        xf = corrtag_data.field('XFULL')
        yf = corrtag_data.field('YFULL')
        
        #lets limit the places
        lim1y = yf[(xf <= (x1 + width)) & (xf >= (x1 - width)) & (yf >= ymin) & (yf <= ymax)]
        lim2y = yf[(xf <= (x2 + width)) & (xf >= (x2 - width))  & (yf >= ymin) & (yf <= ymax)]
        lim3y = yf[(xf <= (x3 + width)) & (xf >= (x3 - width))  & (yf >= ymin) & (yf <= ymax)]
        
        ax = P.subplot(111)
        P.title(title)
        
        n1, bins1, patches1 = ax.hist(lim1y,
                                      bins = (ymax-ymin),
                                      range = ran,
                                      normed = True,
                                      histtype='step',
                                      ec = 'b')
        yr1 = mlab.normpdf(bins1, N.mean(lim1y), N.std(lim1y))
        ax.plot(bins1, yr1, 'b-', lw = 1, label = '%i \AA' % wave1, visible = False)

        n2, bins2, patches2 = ax.hist(lim2y,
                                      bins = (ymax-ymin),
                                      range = ran,
                                      normed = True,
                                      histtype='step',
                                      ec = 'g')
        yr2 = mlab.normpdf(bins2, N.mean(lim2y), N.std(lim2y))
        ax.plot(bins2, yr2, 'g-', lw = 1, label = '%i \AA' % wave2, visible = False)
        
        n3, bins3, patches3 = ax.hist(lim3y,
                                      bins = (ymax-ymin),
                                      range = ran,
                                      normed = True,
                                      histtype='step',
                                      ec = 'r')
        yr3 = mlab.normpdf(bins3, N.mean(lim3y), N.std(lim3y))
        ax.plot(bins3, yr3, 'r-', lw = 1, label = '%i \AA' % wave3, visible = False)
        
        ylimmax = N.max([N.max(n1), N.max(n2), N.max(n3)])

        #extractions
        l1 = extr - (ewidth/2)
        l2 = extr + (ewidth/2)
        ax.axvline(x=l1, ymax=ylimmax*0.2, color='y')
        ax.axvline(x=l2, ymax=ylimmax*0.2, color='y')#, label = 'Extraction Box')

        ax.set_ylim(-0.0001, ylimmax*1.05)

        ax.set_xlabel('y (pixels)')
        ax.set_ylabel('Normalized flux')

        ax.legend(shadow = True)        
        
        P.savefig(output+self.type)
        P.close()
    
    def DispersedLightAcquisitionTimes(self, data, gratings, output):
        '''
        Fig. 8.9 in COS IHB, version 2.0, draft 1
        '''
        do = True

        ax = P.subplot(111)
        P.title('Dispersed-light Acquisition Exposure Times')
        
        for grating in gratings:
            if grating == 'G285M' or grating == 'G185M':
                if do :
                    ax.plot(data[data['grating'] == grating]['flux'], data[data['grating'] == grating]['time'],
                            label = 'G185M \& G285M', ls = '-', lw = 1.4)
                do = False
            else:
                ax.plot(data[data['grating'] == grating]['flux'], data[data['grating'] == grating]['time'],
                        label = grating, ls = '-', lw = 1.4)

        ax.set_xscale('log')
        ax.set_yscale('log')         
        
        ax.set_xlabel('Flux (erg cm$^{-2}$ sec$^{-1}$ \AA$^{-1}$)')
        ax.set_ylabel('Exposure Time (sec)')  
        ax.set_ylim(0.8, 1000)
        #ax.set_xlim()  
        
        ax.yaxis.set_major_formatter(FormatStrFormatter('%i'))
            
        ax.legend(shadow = True)        
        
        P.savefig(output+self.type)
        P.close()        
        