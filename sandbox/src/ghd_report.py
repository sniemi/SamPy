# Useful scripts for GHD reporting. For macro report generated by ARUSER.
# Run on Unix systems only.

# External modules
import os, commands, numpy, re
# http://tkinter.unpythonic.net/wiki/tkFileDialog
import tkFileDialog
# http://docs.python.org/library/email-examples.html
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Compile tallies for GHD macro report.
def ghd_tally():
  """Compile tallies for GHD macro report.
  This procedure is interactive, so follow user prompts.
  For easy usage, save a copy of this code in working directory.

  USAGE: ghd_report.ghd_tally()

  INPUT FILE:
  Output from Generate Report for Help macro.
    
  OUTPUT FILE:
  Macro report with basic tallies and comments.

  EXAMPLE:
  unix> cd working_dir
  unix> ipython
  [1]: import ghd_report [OR reload(ghd_report)]
  [2]: ghd_report.ghd_tally()

  Change log:
  2009/10/22 - Created by P. L. Lim.

  Pey Lian Lim, STScI, 2009
  """

  # Let user choose input file
  print '\n***** CHOOSE INPUT FILE FROM GHD MACRO\n'
  infile = tkFileDialog.askopenfilename(title='Select output file from GHD macro')
  if len(infile) < 1 or not os.path.isfile(infile):
    print 'INVALID FILE:', infile
    return
  print 'INPUT FILE:', infile

  # Convert input file to Unix format
  os.system('dos2unix -ascii '+infile)

  # Let user choose output file
  print '\n***** NAME OUTPUT FILE TO SAVE ENCHANCED MACRO REPORT AS.\nExample: 14feb2009_macroreport.txt\n'
  outfile = tkFileDialog.asksaveasfilename(title='Save enhanced macro report as')
  if len(outfile) < 1 or outfile == infile:
    print 'INVALID FILE:', outfile
    return
  print 'OUTPUT FILE:', outfile
  if os.path.isfile(outfile):
    print 'WARNING: OUTPUT FILE IS OVERWRITTEN'

  # Open files
  fin1 = open(infile, 'r')
  fout1 = open(outfile, 'w')

  cn_size = 11 # Length of a typical call number, e.g., CNSHD123456
  ch_text = 'CNSHD' # All call numbers have this prefix
  ch_size = len(ch_text)  # Length of the prefix
  # Position of platform names (fixed length)
  x1 = 86
  x2 = x1 + 7
  # Status to be alerted (case sensitive)
  stat_closed = 'Closed'
  stat_new = 'New'
  # Initialization
  platforms = []
  pf_counts = []
  cn_closed = []
  cn_new = []

  # Process input file
  for line in fin1:
    row = line.split()
    n_col = len(row)
    if n_col < 1:
      fout1.write('\n')
      continue
    line2 = line[0:len(line)-1]
    callnum = row[0]

    # Count tally
    if len(callnum) == cn_size and callnum[0:ch_size] == ch_text:
      # Extract platform name (spaces removed and force uppercase)
      pf = line[x1:x2].strip().upper()
      # Extract call status of interest
      cs = row[n_col-1]
      if cs == stat_closed:
        cn_closed.append('%s (%s)' % (callnum, pf))
      elif cs == stat_new:
        cn_new.append('%s (%s)' % (callnum, pf))
      # Store tally for depending on platform
      try:
        idx = platforms.index(pf)
      except ValueError:
        idx = len(platforms)
        platforms.append(pf)
        pf_counts.append(0)
      pf_counts[idx] += 1
    # End of if statement

    # Write to output file
    fout1.write('%s\n' % (line2))
  # End of line loop
  fin1.close()

  # Check tallies
  n_pf = len(platforms)
  if n_pf < 1:
    print 'NO CALLS FOUND. EXITING...'
    fout1.close()
    return
  
  # Sum up tallies
  tot_calls = numpy.sum(pf_counts)
  n_new = len(cn_new)
  n_closed = len(cn_closed)

  # Alert user of calls that might have been merged
  print ' '
  for i in range(0, n_closed):
    print cn_closed[i]
  if n_closed > 0:
    print '***** %i CLOSED CALLS FOUND ABOVE. CHECK IF THEY ARE MERGED AND MANUALLY WRITE DOWN RELEVANT INFO.' % (n_closed)
    x_user = raw_input('PAUSED. ENTER ANY CHAR TO CONTINUE WHEN READY: ')

  # Process total calls
  x_user = raw_input('\nENTER NUMBER OF MERGED CALLS: ')
  n_merged = int(x_user)
  tot_calls -= n_merged
  fout1.write('\nNumber of calls: %i\n\n' % (tot_calls))

  # Process merged calls
  i = 0
  while i < n_merged:
    x_user = raw_input('\nENTER PLATFORM OF MERGED CALL # %i: ' % (i+1))
    pf = x_user.upper()
    try:
      idx = platforms.index(pf)
    except ValueError:
      print 'PLATFORM %s NOT IN REPORT. TRY AGAIN.' % (pf)
      idx = -1
      i -= 1 # Let user try again
    if idx != -1:
      pf_counts[idx] -= 1
    i += 1
  # End of while loop

  # Insert tallies of sorted platforms
  idx = numpy.argsort(platforms)
  for i in range(0, n_pf):
    j = idx[i]
    fout1.write('%-7s: %3i\n' % (platforms[j], pf_counts[j]))

  # Alert user of calls that might need follow-up
  print ' '
  for i in range(0, n_new):
    print cn_new[i]
  if n_new > 0:
    print '***** %i NEW CALLS FOUND ABOVE. CHECK IF THEY NEED FOLLOW-UP AND MANUALLY WRITE DOWN RELEVANT INFO.' % (n_new)
    x_user = raw_input('PAUSED. ENTER ANY CHAR TO CONTINUE WHEN READY: ')

  # Insert comments
  print '\n***** ENTER COMMENT(S), ONE LINE AT A TIME. ESPECIALLY, WRITE DOWN MERGED CALLS AND CALLS SET BACK TO NEW. IF NONE, ENTER NONE AND THEN ENTER Q. DO NOT ENTER WHO IS ON DUTY NEXT YET.'
  fout1.write('\nComments:\n')
  x_user = 'y'
  while x_user not in ('q','Q'):
    cmt = raw_input('\nCOMMENT: ')
    fout1.write('%s\n' % (cmt))
    x_user = raw_input('\nENTER Q TO QUIT OR ANY OTHER CHAR FOR MORE COMMENTS: ')
  # End of while loop

  # Insert next person on duty
  x_user = raw_input('\nENTER NEXT PERSON ON DUTY: ')
  cmt = raw_input('ENTER HIS/HER BACK-UP: ')
  fout1.write('\n%s is on duty next with %s as back-up.\n' % (x_user, cmt))

  # Close output file
  fout1.close()
  print '\n***** CHECK OUTPUT FILE:', outfile  
# End of ghd_tally()

# Send macro report email to GHD mailing list.
def ghd_email(mailto='ins_genhelpdesk@stsci.edu', mailcc=''):
  """Send macro report email to GHD mailing list.
  This procedure is interactive, so follow user prompts.
  Need Internet connection to send email successfully.
  To specify multiple recipients, separate their emails by comma.
  
  USAGE: ghd_report.ghd_email([mailto=mailto, mailcc=mailcc])

  OPTIONAL KEYWORD:
  mailto:
    Email address(es) of recipient(s).
    Default is pre-defined GHD mailing list address.
  mailcc:
    Email address(es) of carbon copy recipient(s).
    Default is none.

  EXAMPLE:
  unix> cd working_dir
  unix> ipython
  [1]: import ghd_report [OR reload(ghd_report)]
  [2]: ghd_report.ghd_email()
           OR
  [2]: ghd_report.ghd_email(mailto='new_list@host.ext')
           OR
  [2]: ghd_report.ghd_email(mailcc='someone1@host.ext,someone2@host.ext')
           OR
  [2]: ghd_report.ghd_email(mailto='new_list@host.ext', mailcc='someone@host.ext')
  
  Change log:
  2009/10/22 - Created by P. L. Lim.

  Pey Lian Lim, STScI, 2009
  """

  # Initialization
  spc = ' '
  comma = ','
  endl = '\r\n'
  divider = '======================================'
  txt_sig = 'Email generated by ghd_report.py'
  svr_addr = 'smtp.stsci.edu' # STScI SMTP server

  #############################
  # STEP 1 - GHD REPORT EMAIL #
  #############################

  # Get attachment from user
  infile = tkFileDialog.askopenfilename(title='Select email attachment')
  if len(infile) < 1 or not os.path.isfile(infile):
    print 'INVALID FILE:', infile
    return
  print '\nGHD REPORT TO ATTACH TO EMAIL:', infile
  fname = os.path.basename(infile)

  # Get name from sender
  snd_name = raw_input('\nENTER YOUR NAME: ')
  
  # Guess sender email from whoami with override option
  email_from = commands.getoutput('whoami') + '@stsci.edu'
  x_user = raw_input('\nIS %s YOUR EMAIL (Y/N)? ' % (email_from))
  if x_user not in ('y','Y'):
    email_from = raw_input('\nENTER YOUR EMAIL: ')

  # Process mailto and mailcc
  if not mailto:
    print 'INVALID MAILTO:', mailto
    return

  # Email subject
  txt_subject = 'General Help Desk Report'

  # Email header
  msg = MIMEMultipart()
  msg['Subject'] = txt_subject
  msg['From'] = email_from
  msg['To'] = mailto
  email_to = mailto.split(comma)
  if mailcc:
    msg['Cc'] = mailcc
    email_to += mailcc.split(comma)

  # Generic intro message. Change as needed.
  txt_body = 'Hi %s,%s%s' % ('GHDers', endl, endl)
  txt_body += '%s%s%s' % ('Attached is the GHD macro report.', endl, endl)

  # Extract info from attachment for email
  is_found = 0
  txt_skipto = 'Average Route Time'
  fin1 = open(infile, 'r')
  rcp_name2 = 'Unknown'
  nextduty_str = 'on duty next'
  # Skip to tallies and comments
  for line in fin1:
    row = line.split()
    n_cols = len(row)
    if n_cols > 2 and cmp(spc.join(row[0:3]), txt_skipto) == 0:
      is_found = 1
      break
  # End of first line loop
  # Put the rest of the report in email
  if is_found:
    for line in fin1:
      txt_body += line
      # Auto search for next on duty
      if re.search(nextduty_str, line):
        rcp_name2 = line.split()[0]
    # End of second line loop
  else:
    txt_body += 'Ops! Cannot read tallies and comments from %s!%s' % (fname, endl)
    print '\nFAILED TO EXTRACT TALLIES AND COMMENTS FROM GHD REPORT! PLEASE CHECK', infile
  txt_body += endl
  # Close attachment
  fin1.close()

  # Email signature
  txt_body += '%s,%s%s%s' % ('Sincerely', endl, snd_name, endl)
  txt_body += '%s%s%s' % (endl, txt_sig, endl)

  # Put email body in email
  msg.attach(MIMEText(txt_body))

  # Add attachment
  fp = open(infile)
  atth = MIMEText(fp.read())
  fp.close()
  atth.add_header('Content-Disposition', 'attachment', filename=fname)
  msg.attach(atth)

  # Let user proof read with option to abort
  print '\nEMAIL CONTENT TO BE SENT:\n%s\n%s\n%s\n' % (divider, msg, divider)
  x_user = raw_input('SEND EMAIL (Y/N)? ')

  # Send email via SMTP server
  if x_user in ('y','Y'):
    s = smtplib.SMTP(svr_addr)
    s.sendmail(email_from, email_to, msg.as_string())
    s.quit()
    print '\nEMAIL SENT!'
  else:
    print '\nEMAIL ABORTED!'

  ###########################
  # STEP 2 - REMINDER EMAIL #
  ###########################

  # Recipient's name
  x_user = raw_input('\n%s IS ON DUTY NEXT (Y/N)? ' % (rcp_name2))
  if x_user not in ('y','Y'):
    rcp_name2 = raw_input('\nENTER NAME OF NEXT ON DUTY: ')

  # Confirm recipient address
  mailto2 = raw_input('\nENTER EMAIL OF %s: ' % (rcp_name2))
  if not mailto2:
    print 'INVALID MAILTO:', mailto2
    return

  # Confirm cc address(es)
  mailcc2 = 'lim@stsci.edu,mack@stsci.edu'
  print '\nCC WILL BE SENT TO THE FOLLOWING RECIPIENT(S):', mailcc2
  x_user = raw_input('ARE THE ADDRESS(ES) ABOVE CORRECT (Y/N)? ')
  if x_user not in ('y','Y'):
    mailcc2 = raw_input('\nENTER NEW CC RECIPIENT(S) OR JUST PRESS ENTER IF NO CC: ')

  # Email subject
  txt_subject2 = 'GHD Duty Reminder'

  # Email header
  msg2 = MIMEMultipart()
  msg2['Subject'] = txt_subject2
  msg2['From'] = email_from
  msg2['To'] = mailto2
  email_to2 = mailto2.split(comma)
  if mailcc2:
    msg2['Cc'] = mailcc2
    email_to2 += mailcc2.split(comma)

  # Compose email body
  txt_body2 = 'Hi %s,%s%s' % (rcp_name2, endl, endl)
  txt_body2 += '%s%s%s' % ('This is a friendly reminder that you are on GHD duty next.', endl, endl)
  txt_body2 += '%s,%s%s%s' % ('Sincerely', endl, snd_name, endl)
  txt_body2 += '%s%s%s' % (endl, txt_sig, endl)

  # Put email body in email
  msg2.attach(MIMEText(txt_body2))

  # Let user proof read with option to abort
  print '\nEMAIL CONTENT TO BE SENT:\n%s\n%s\n%s\n' % (divider, msg2, divider)
  x_user = raw_input('SEND EMAIL (Y/N)? ')

  # Send email
  if x_user in ('y','Y'):
    s = smtplib.SMTP(svr_addr)
    s.sendmail(email_from, email_to2, msg2.as_string())
    s.quit()
    print '\nEMAIL SENT!'
  else:
    print '\nEMAIL ABORTED!'
# End of ghd_email()
